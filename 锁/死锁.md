### 同步和锁的异同

- Synchronized 和 Java.util.concurrent.locks.Lock 的异同？

  相同：Lock 能实现 Synchronized s所实现的所有功能。

  不同：Lock 比 synchronized 有更好的**线程语义**和**性能**；Synchronized 会**自动释放锁**，而 Lock 必须**手动释放**（并且必须在 **finally** 中释放）。

### 确保 N 个线程访问 N 个资源，但同时不会导致死锁？（死锁避免）

- **指定线程获取锁的顺序，并强制线程按照指定的顺序获取锁。**
- 破坏死锁的四个条件，但是互斥不能被破坏，所以有三种方法：
  - 破坏占有并等待：（进程必须等待所有要请求的资源都空闲时才能申请资源，这种方法会严重浪费资源）**允许进程获取初期所需资源资源之后，便可以开始运行，运行过程中逐步释放自己已经占有的资源。**
  - 破坏不可抢占：为进程分配抢占优先级，这种方法代价大实现复杂。
  - 破坏循环： 对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率都比前两种高，但是前期需要对设备指定序号，新设备加入会有问题，其次对编程也有限制。

### 什么是死锁？

- 进程 1 占有 A 资源，进程 2 占有 B 资源。此时 1 需要B资源，但是要等待 2 释放B；同时 2 需要资源 A，但是要等待 1 释放资源A。进程1和2都不知道陷入了这种循环的存在，就一直在等待，就彼此都得不到需要的资源。他们将永远阻塞下去，称为死锁。

### Synchronized 的可重入实现

- 每个锁关联一个线程持有者和一个计数器，当计数器为 0 时表示该锁不被任何线程持有，任何线程都可以请求它。
  - 当一个线程请求该锁成功之后，JVM会记下持有锁的线程，并且锁的计数器加 1；
  - 其他线程线程请求这个锁则必须等待；而该持有锁的线程再次请求该锁时，可以再次拿到该锁，同时计数器加 1；
  - 当线程退出一个Synchronized 方法或者块时，计数器减 1 ,如果计数器为 0 ，则持有者释放该锁。